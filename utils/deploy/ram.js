'use strict'

const _ = require('lodash')

const Client = require('./client')
const { promiseRetry } = require('./utils')
const Logger = require('../logger')
const ServerlessError = require('../error')

const assumeRolePolicyDefault = {
  Statement: [
    {
      Action: 'sts:AssumeRole',
      Effect: 'Allow',
      Principal: {
        Service: [
          'fc.aliyuncs.com'
        ]
      }
    }
  ],
  Version: '1'
};

class RAM extends Client {
  constructor (credentials) {
    super(credentials);
    this.ramClient = this.buildRamClient();
    this.logger = new Logger();
  }

  async getRamRole (roleName) {
    try {
      return await this.ramClient.getRole({ RoleName: roleName });
    } catch (ex) {
      if (ex.name === 'EntityNotExist.RoleError') {
        this.logger.info(`Role not exists: ${roleName}`);
      } else {
        await ServerlessError(ex, true);
      }
    }
  }

  async existsRamRole (roleName) {
    try {
      await this.ramClient.getRole({
        RoleName: roleName
      })
      return true
    } catch (ex) {
      if (ex.name === 'EntityNotExist.RoleError') {
        return false
      }
      new ServerlessError(ex);
    }
  }

  async makeRole (roleName, createRoleIfNotExist, description = 'FunctionCompute Default Role', assumeRolePolicy) {
    let role;

    await promiseRetry(async (retry, times) => {
      try {
        role = await this.getRamRole(roleName);

        if (!assumeRolePolicy) {
          assumeRolePolicy = assumeRolePolicyDefault;
        }

        if (role) {
          this.logger.info(`Role ${roleName} already exists`)
        } else if (createRoleIfNotExist) {
          this.logger.info(`Generating role: ${roleName}`)
          role = await this.ramClient.createRole({
            RoleName: roleName,
            Description: description,
            AssumeRolePolicyDocument: JSON.stringify(assumeRolePolicy)
          })
          this.logger.info(`Role generated: ${roleName}`)
        } else {
          new ServerlessError({ name: 'RoleNotExist', message: `role ${roleName} not exist` });
        }
      } catch (ex) {
        if (ex.code && ex.code.startsWith('InvalidParameter')) {
          new ServerlessError(ex);
        } else if (ex.code && ex.code === 'NoPermission') {
          new ServerlessError(ex);
        } else {
          this.logger.info(`Retry ${times} times`)
          retry(ex)
        }
      }
    })

    return role;
  }

  async deletePolicyNotDefaultVersion (policyName) {
    const listResponse = await this.ramClient.listPolicyVersions({
      PolicyType: 'Custom',
      PolicyName: policyName
    });

    const versions = (listResponse.PolicyVersions || {}).PolicyVersion
    if (versions) {
      for (const version of versions) {
        if (version.IsDefaultVersion === false) {
          await this.ramClient.deletePolicyVersion({
            PolicyName: policyName,
            VersionId: version.VersionId
          })
        }
      }
    }
  }

  async makePolicy (policyName, policyDocument) {
    let exists = true
    await promiseRetry(async (retry, times) => {
      try {
        try {
          await this.ramClient.getPolicy({
            PolicyType: 'Custom',
            PolicyName: policyName
          })
        } catch (ex) {
          if (ex.code !== 'EntityNotExist.Policy') {
            new ServerlessError(ex);
          } else { exists = false }
        }

        if (!exists) {
          await this.ramClient.createPolicy({
            PolicyName: policyName,
            Description: 'generated by serverless tool',
            PolicyDocument: JSON.stringify(policyDocument)
          });
        } else {
          // avoid limitExceeded.Policy.Version
          await this.deletePolicyNotDefaultVersion(policyName);

          await this.ramClient.createPolicyVersion({
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDocument),
            SetAsDefault: true
          });
        }
      } catch (ex) {
        if (ex.code && ex.code === 'NoPermission') {
          new ServerlessError(ex);
        }
        this.logger.info(`Retry ${times} times`);
        retry(ex);
      }
    })
  }

  async attachPolicyToRole (policyName, roleName, policyType = 'System') {
    await promiseRetry(async (retry, times) => {
      try {
        const policies = await this.ramClient.listPoliciesForRole({
          RoleName: roleName
        });

        const policy = policies.Policies.Policy.find((item) => {
          return _.toLower(item.PolicyName) === _.toLower(policyName)
        });
        if (!policy) {
          await this.ramClient.attachPolicyToRole({
            PolicyType: policyType,
            PolicyName: policyName,
            RoleName: roleName
          });
        }
      } catch (ex) {
        if (ex.code && ex.code === 'NoPermission') {
          new ServerlessError(ex);
        }

        this.logger.info(`Retry ${times} times`);
        retry(ex);
      }
    })
  }

  async makeAndAttachPolicy (policyName, policyDocument, roleName) {
    await this.makePolicy(policyName, policyDocument);
    await this.attachPolicyToRole(policyName, roleName, 'Custom');
  }
}

module.exports = RAM
